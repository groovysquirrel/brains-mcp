# Llama Streaming Implementation Fix - April 7, 2025

## Issue
The Llama streaming implementation was experiencing an infinite loop where the same request was being sent to Bedrock repeatedly. This was causing the model to generate repetitive responses and creating unnecessary API calls.

## Root Cause
The issue stemmed from a circular dependency in our streaming implementation:

1. `MetaVendor.streamProcess` was calling `provider.streamChat`
2. `BedrockProvider.streamChat` was calling back into `vendor.streamProcess`
3. This created an infinite loop of requests

## Solution
We fixed this by:

1. Moving the Bedrock streaming logic directly into the `MetaVendor` class
2. Using the AWS SDK's `InvokeModelWithResponseStreamCommand` directly
3. Properly formatting the prompt according to Llama 3's instruction format:
   ```typescript
   const formattedPrompt = `<|begin_of_text|><|start_header_id|>user<|end_header_id|>
   ${userMessage.content}
   <|eot_id|>
   <|start_header_id|>assistant<|end_header_id|>`;
   ```

## Key Learnings

1. **Vendor-Specific Logic**: Streaming implementations should be vendor-specific and not rely on provider-level abstractions for streaming. Each vendor may have unique requirements for:
   - Prompt formatting
   - Response handling
   - Chunk processing

2. **Avoid Circular Dependencies**: When implementing streaming:
   - Keep the streaming logic in one place (either provider or vendor)
   - Don't create circular calls between provider and vendor
   - Use direct AWS SDK calls when needed

3. **Proper Prompt Formatting**: Llama 3 requires specific instruction format markers:
   - `<|begin_of_text|>` to start
   - `<|start_header_id|>user<|end_header_id|>` for user messages
   - `<|eot_id|>` to end user messages
   - `<|start_header_id|>assistant<|end_header_id|>` to start assistant response

4. **Streaming State Management**: 
   - Each vendor should manage its own streaming state
   - Don't try to track state across provider/vendor boundaries
   - Let the AWS SDK handle the streaming mechanics

## Next Steps

1. Consider refactoring the provider interface to better support vendor-specific streaming implementations
2. Add proper typing for the Bedrock client in the provider interface
3. Document the streaming requirements for each vendor in the codebase
4. Add tests to verify streaming behavior for each vendor
